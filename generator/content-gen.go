package generator

import (
	"fmt"
	"path/filepath"
	"strings"
)

// generateContent returns boilerplate content based on file path.
func generateContent(templateName, path string) string {
	base := filepath.Base(path)
	ext := filepath.Ext(path)
	name := strings.TrimSuffix(base, ext)
	pkg := filepath.Base(filepath.Dir(path))

	// Generate content based on file type
	switch {
	case isDockerFile(base):
		return generateDockerfile()
	case isDockerCompose(base):
		return generateDockerCompose(templateName)
	case isMiddleware(path, name):
		return generateMiddleware(pkg)
	case isTestFile(ext, name):
		return generateTestFile(pkg)
	case isGoFile(ext):
		return generateGoFile(pkg, name, path)
	case isMarkdown(ext):
		return generateMarkdown(name)
	case isGoMod(ext):
		return generateGoMod()
	case isGoSum(ext):
		return generateGoSum()
	case isMakeFile(name):
		return generateMakeFile(name)
	default:
		return ""
	}
}

// File type identification functions

func isDockerFile(base string) bool {
	return strings.EqualFold(base, "Dockerfile")
}

func isDockerCompose(base string) bool {
	return strings.EqualFold(base, "docker-compose.yml")
}

func isMiddleware(path, name string) bool {
	return strings.Contains(path, "middleware") && !strings.HasSuffix(name, "_test")
}

func isTestFile(ext, name string) bool {
	return ext == ".go" && strings.HasSuffix(name, "_test")
}

func isGoFile(ext string) bool {
	return ext == ".go"
}

func isMarkdown(ext string) bool {
	return ext == ".md"
}

func isGoMod(ext string) bool {
	return ext == ".mod"
}

func isGoSum(ext string) bool {
	return ext == ".sum"
}

func isMakeFile(name string) bool {
	return name == "Makefile"
}

// Content generation functions

func generateDockerfile() string {
	return `FROM golang:1.23-alpine
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -o main main.go
EXPOSE 8080
CMD ["./main"]`
}

func generateDockerCompose(templateName string) string {
	if strings.Contains(templateName, "api-pgsql") {
		return `version: "3.9"

services:
  app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
    depends_on:
      - postgres
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - DB_NAME=appdb

  postgres:
    image: postgres:16
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: appdb
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
`
	}

	return `version: "3.9"

services:
  app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/app
    depends_on:
      - mongo

  mongo:
    image: mongo:7
    ports:
      - "27017:27017"
    volumes:
      - mongodata:/data/db

volumes:
  mongodata:
`
}

func generateMiddleware(pkg string) string {
	return fmt.Sprintf(`package %s

import "fmt"

func AuthMiddleware() {
	fmt.Println("Middleware executed")
}
`, pkg)
}

func generateTestFile(pkg string) string {
	return fmt.Sprintf(`package %s

import "testing"

func TestExample(t *testing.T) {
	t.Log("example test")
}
`, pkg)
}

func generateGoFile(pkg, name, path string) string {
	// Special cases for specific Go files
	switch name {
	case "main":
		return `package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}
`
	case "config":
		return `package config

import "fmt"

func LoadConfig() {
	fmt.Println("Loading config...")
}
`
	default:
		// SQLite repository special case
		if strings.Contains(path, "repository") && strings.Contains(path, "sqlite") {
			return generateSQLiteRepository(pkg, name)
		}

		// Default boilerplate for other Go files
		return generateDefaultGoFile(pkg, name)
	}
}

func generateSQLiteRepository(pkg, name string) string {
	return fmt.Sprintf(`package %s

import (
	"database/sql"
	_ "github.com/mattn/go-sqlite3"
)

type %s struct {
	DB *sql.DB
}

func New%s(dbPath string) (*%s, error) {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, err
	}
	return &%s{DB: db}, nil
}
`, pkg, toCamel(name), toCamel(name), toCamel(name), toCamel(name))
}

func generateDefaultGoFile(pkg, name string) string {
	return fmt.Sprintf(`package %s

type %s struct {
}

func New%s() *%s {
	return &%s{}
}
`, pkg, toCamel(name), toCamel(name), toCamel(name), toCamel(name))
}

func generateMarkdown(name string) string {
	if name == "README" {
		return "# Project\n\nGenerated by gotemplater.\n"
	}
	return ""
}

func generateGoMod() string {
	return "module myapp\n\ngo 1.24.3"
}

func generateGoSum() string {
	return ""
}

func generateMakeFile(name string) string {
	return fmt.Sprintf(`APP_NAME=%s

.PHONY: run build build-windows build-darwin build-linux clean

run:
	go run main.go

build: build-windows build-darwin build-linux

build-windows:
	GOOS=windows GOARCH=amd64 go build -o $(APP_NAME).exe

build-darwin:
	GOOS=darwin GOARCH=amd64 go build -o $(APP_NAME)-darwin-amd64
	GOOS=darwin GOARCH=arm64 go build -o $(APP_NAME)-darwin-arm64

build-linux:
	GOOS=linux GOARCH=amd64 go build -o $(APP_NAME)-linux-amd64

clean:
	rm -f $(APP_NAME).exe $(APP_NAME)-darwin-amd64 $(APP_NAME)-darwin-arm64 $(APP_NAME)-linux-amd64

help:
	@echo "Available targets:"
	@echo "  run           - Run the application"
	@echo "  build         - Build for all platforms"
	@echo "  build-windows - Build for Windows"
	@echo "  build-darwin  - Build for macOS (Intel and Apple Silicon)"
	@echo "  build-linux   - Build for Linux"
	@echo "  clean         - Remove all built binaries"
	@echo "  help          - Show this help message"`, name)
}
